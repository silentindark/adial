<?php
defined('BASEPATH') OR exit('No direct script access allowed');

/**
 * Dialplan Generator Library
 * Generates Asterisk dialplan configuration from IVR database entries
 */
class Dialplan_generator {

    protected $CI;
    private $dialplanFile = '/etc/asterisk/extensions_dialer.conf';
    private $soundsPath = '/var/lib/asterisk/sounds/dialer';
    private $recordingsPath = '/var/spool/asterisk/monitor/adial';

    public function __construct() {
        $this->CI =& get_instance();
        $this->CI->load->model('Ivr_menu_model');
        $this->CI->load->model('Ivr_action_model');

        // Load config if available
        $this->CI->load->config('asterisk', TRUE, TRUE);

        $soundsDir = $this->CI->config->item('asterisk_sounds_dir');
        if ($soundsDir) {
            $this->soundsPath = rtrim($soundsDir, '/');
        }
    }

    /**
     * Generate complete dialplan
     */
    public function generate() {
        try {
            log_message('info', 'Dialplan generation started');

            // Load all IVR menus with actions
            $menus = $this->loadIVRMenus();

            // Build dialplan content
            $content = $this->buildHeader();
            $content .= $this->buildOriginationContext();

            foreach ($menus as $menu) {
                $content .= $this->buildIVRContext($menu);
            }

            // Write to file
            $this->writeDialplanFile($content);

            // Reload Asterisk dialplan
            $this->reloadDialplan();

            log_message('info', 'Dialplan generation completed successfully');

            return true;

        } catch (Exception $e) {
            log_message('error', 'Dialplan generation failed: ' . $e->getMessage());
            return false;
        }
    }

    /**
     * Load all IVR menus with their actions
     */
    private function loadIVRMenus() {
        $menus = $this->CI->Ivr_menu_model->get_all();

        foreach ($menus as $menu) {
            $menu->actions = $this->CI->Ivr_action_model->get_by_menu($menu->id);
        }

        return $menus;
    }

    /**
     * Build dialplan header
     */
    private function buildHeader() {
        $timestamp = date('Y-m-d H:i:s');

        return <<<EOT
;
; A-Dial Dialplan Configuration
; Auto-generated by Dialplan_generator
; Generated: {$timestamp}
;
; WARNING: DO NOT EDIT THIS FILE MANUALLY
; Changes will be overwritten on next generation
;


EOT;
    }

    /**
     * Build campaign dialplan contexts
     */
    private function buildOriginationContext() {
        return <<<'EOT'
[dialer_out]
; Outbound dialing context - uses TRUNK variable to dial external numbers
; DIAL_TIMEOUT: time to wait for answer (15-180 sec, default 30)
; CALL_TIMEOUT: max call duration after answer (30-3600 sec, default 600)
exten => _X.,1,NoOp(Dialer Outbound: ${EXTEN} via ${TRUNK})
 same => n,Set(CDR(accountcode)=${CAMPAIGN_ID})
 same => n,Set(CDR(userfield)=${CAMPAIGN_ID}:${NUMBER_ID})
 same => n,Set(__CAMPAIGN_ID=${CAMPAIGN_ID})
 same => n,Set(__NUMBER_ID=${NUMBER_ID})
 same => n,Set(__DIAL_TIMEOUT=${DIAL_TIMEOUT})
 same => n,Set(__CALL_TIMEOUT=${CALL_TIMEOUT})
 same => n,Set(YEAR=${STRFTIME(${EPOCH},,%Y)})
 same => n,Set(MONTH=${STRFTIME(${EPOCH},,%m)})
 same => n,Set(DAY=${STRFTIME(${EPOCH},,%d)})
 same => n,Set(CALLFILENAME=${UNIQUEID}-${EXTEN}-${CAMPAIGN_ID})
 same => n,System(mkdir -p /var/spool/asterisk/monitor/dialer/${YEAR}/${MONTH}/${DAY})
 same => n,MixMonitor(/var/spool/asterisk/monitor/dialer/${YEAR}/${MONTH}/${DAY}/${CALLFILENAME}.wav,b)
 same => n,Dial(${TRUNK}/${EXTEN},${DIAL_TIMEOUT})
 same => n,Hangup()

[dialer_agent]
; Agent destination context - dials agent extension using CHANNEL_TYPE
; Uses CALL_TIMEOUT to limit maximum conversation duration (L option in milliseconds)
exten => _X.,1,NoOp(Dialer Agent: Connecting to ${CHANNEL_TYPE}/${EXTEN})
 same => n,Set(CDR(accountcode)=${CAMPAIGN_ID})
 same => n,Set(CALL_TIMEOUT_MS=$[${CALL_TIMEOUT}*1000])
 same => n,UserEvent(AgentConnect,Campaign:${CAMPAIGN_ID},Number:${NUMBER_ID},Agent:${EXTEN},ChannelType:${CHANNEL_TYPE})
 same => n,Dial(${CHANNEL_TYPE}/${EXTEN},${DIAL_TIMEOUT},L(${CALL_TIMEOUT_MS}))
 same => n,NoOp(Agent Dial Status: ${DIALSTATUS})
 same => n,Hangup()

[dialer_queue]
; Queue destination context - puts caller into queue
; Uses CALL_TIMEOUT to limit maximum time in queue + conversation
exten => _X.,1,NoOp(Dialer Queue: Adding to queue ${EXTEN})
 same => n,Set(CDR(accountcode)=${CAMPAIGN_ID})
 same => n,Set(TIMEOUT(absolute)=${CALL_TIMEOUT})
 same => n,UserEvent(QueueConnect,Campaign:${CAMPAIGN_ID},Number:${NUMBER_ID},Queue:${EXTEN})
 same => n,Queue(${EXTEN},t,,,${DIAL_TIMEOUT})
 same => n,NoOp(Queue Status: ${QUEUESTATUS})
 same => n,Hangup()


EOT;
    }

    /**
     * Build IVR context for a menu
     */
    private function buildIVRContext($menu) {
        $menuId = $menu->id;
        $menuName = $this->sanitizeName($menu->name);
        $audioFile = $menu->audio_file;
        $timeout = $menu->timeout ?: 10;
        $maxDigits = $menu->max_digits ?: 1;

        // Build context header
        $context = "[ivr-menu-{$menuId}]\n";
        $context .= "; IVR: {$menuName}\n";
        $context .= "exten => s,1,NoOp(IVR Menu: {$menuName})\n";
        $context .= " same => n,Answer()\n";
        $context .= " same => n,Wait(1)\n";
        $context .= " same => n,Set(TIMEOUT(digit)=5)\n";
        $context .= " same => n,Set(TIMEOUT(response)={$timeout})\n";

        // Play audio file (without extension - Asterisk adds it)
        $audioPath = $this->soundsPath . '/' . pathinfo($audioFile, PATHINFO_FILENAME);
        $context .= " same => n,Background({$audioPath})\n";
        $context .= " same => n,WaitExten({$timeout})\n";
        $context .= "\n";

        // Build actions for each DTMF digit
        if (!empty($menu->actions)) {
            foreach ($menu->actions as $action) {
                $context .= $this->buildAction($action, $menu);
            }
        }

        // Timeout handler
        $context .= "exten => t,1,NoOp(Timeout)\n";
        $context .= " same => n,Playback(vm-goodbye)\n";
        $context .= " same => n,Hangup()\n";
        $context .= "\n";

        // Invalid input handler
        $context .= "exten => i,1,NoOp(Invalid input)\n";
        $context .= " same => n,Playback(invalid)\n";
        $context .= " same => n,Goto(s,4)\n"; // Go back to Background step
        $context .= "\n\n";

        return $context;
    }

    /**
     * Build dialplan for a single IVR action
     */
    private function buildAction($action, $menu) {
        $digit = $action->dtmf_digit;
        $actionType = $action->action_type;
        $actionValue = $action->action_value;
        $channelType = $action->channel_type ?: 'sip';

        $content = "exten => {$digit},1,NoOp(Action: {$actionType})\n";
        $content .= " same => n,UserEvent(IVRAction,Campaign:\${CAMPAIGN_ID},Number:\${NUMBER_ID},Digit:{$digit},Action:{$actionType})\n";

        switch ($actionType) {
            case 'exten':
                // Extension transfer via LOCAL channel
                $content .= " same => n,NoOp(Transferring to extension {$actionValue} via LOCAL channel)\n";
                $content .= " same => n,Dial(LOCAL/{$actionValue}@from-internal,60,g)\n";
                $content .= " same => n,Hangup()\n";
                break;

            case 'queue':
                // Queue transfer
                $content .= " same => n,NoOp(Transferring to queue {$actionValue})\n";
                $content .= " same => n,Queue({$actionValue},t,,,60)\n";
                $content .= " same => n,Hangup()\n";
                break;

            case 'goto_ivr':
                // Go to another IVR menu
                $targetMenuId = $actionValue;
                $content .= " same => n,NoOp(Going to IVR menu {$targetMenuId})\n";
                $content .= " same => n,Goto(ivr-menu-{$targetMenuId},s,1)\n";
                break;

            case 'hangup':
                // Hangup call
                $content .= " same => n,NoOp(Hanging up call)\n";
                $content .= " same => n,Playback(vm-goodbye)\n";
                $content .= " same => n,Hangup()\n";
                break;

            default:
                // Unknown action type - just hangup
                $content .= " same => n,NoOp(Unknown action type: {$actionType})\n";
                $content .= " same => n,Hangup()\n";
                break;
        }

        $content .= "\n";

        return $content;
    }

    /**
     * Sanitize name for use in dialplan comments
     */
    private function sanitizeName($name) {
        // Remove special characters that could break dialplan
        return preg_replace('/[^a-zA-Z0-9 _-]/', '', $name);
    }

    /**
     * Write dialplan to file
     */
    private function writeDialplanFile($content) {
        // Check if we have write permission
        if (file_exists($this->dialplanFile) && !is_writable($this->dialplanFile)) {
            throw new Exception("Dialplan file is not writable: {$this->dialplanFile}");
        }

        $parentDir = dirname($this->dialplanFile);
        if (!is_dir($parentDir)) {
            throw new Exception("Dialplan directory does not exist: {$parentDir}");
        }

        if (!is_writable($parentDir)) {
            throw new Exception("Dialplan directory is not writable: {$parentDir}");
        }

        // Write to temporary file first
        $tempFile = $this->dialplanFile . '.tmp';
        $bytes = file_put_contents($tempFile, $content);

        if ($bytes === false) {
            throw new Exception("Failed to write dialplan to temporary file: {$tempFile}");
        }

        // Atomic rename
        if (!rename($tempFile, $this->dialplanFile)) {
            throw new Exception("Failed to rename temporary dialplan file");
        }

        log_message('info', "Dialplan written to {$this->dialplanFile} ({$bytes} bytes)");
    }

    /**
     * Reload Asterisk dialplan
     */
    private function reloadDialplan() {
        exec('asterisk -rx "dialplan reload"', $output, $returnCode);

        if ($returnCode !== 0) {
            $outputStr = implode("\n", $output);
            throw new Exception("Failed to reload dialplan: {$outputStr}");
        }

        log_message('info', 'Asterisk dialplan reloaded successfully');
    }

    /**
     * Validate generated dialplan (optional - for debugging)
     */
    public function validate() {
        if (!file_exists($this->dialplanFile)) {
            return ['valid' => false, 'error' => 'Dialplan file does not exist'];
        }

        // Check syntax by trying to show a context
        exec('asterisk -rx "dialplan show dialer-origination"', $output, $returnCode);

        if ($returnCode !== 0) {
            return ['valid' => false, 'error' => 'Failed to query dialplan'];
        }

        $outputStr = implode("\n", $output);

        if (strpos($outputStr, 'There is no existence of') !== false) {
            return ['valid' => false, 'error' => 'Dialplan context not found'];
        }

        return ['valid' => true, 'output' => $outputStr];
    }

    /**
     * Get dialplan file path
     */
    public function getDialplanFile() {
        return $this->dialplanFile;
    }

    /**
     * Get generated dialplan content (for preview/debugging)
     */
    public function getDialplanContent() {
        if (file_exists($this->dialplanFile)) {
            return file_get_contents($this->dialplanFile);
        }
        return null;
    }
}
